# Predicting Red Hat Business Value

Team members: Colby Meline, Yu-Ting Chen

![Red_Hat_Kaggle_Co-brand_rgb_logo.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAADeMAAAL/CAYAAABfkT2CAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR42uzdv29Ud7rH8c8TpQTZLTR4pZVTYsH2nj8ABG3S2NuwJbmb2+M/YKO4vdvY1W4Z62Z7TL8k3jJoJXwbKJco6c8tzvHisMDXmPk9r5f0lccmOTPzzIHGeuuprusCAAAAAAAAALT9duM3H/JL9if/PH0+MjUAAAAAAFgOnxgBAAAAAAAAAAAAAAAAALyfGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAAAAAAAAAAAAAaxHgAAAAAAAAAAAAAAAAA0CDGAwAAAAAAAAAAAAAAAIAGMR4AAAAAAAAAAAAAAAAANIjxAAAAAAAAAAAAAAAAAKBBjAcAAAAAAAAAAAAAAAAADWI8AAAAAAAAAAAAAAAAAGgQ4wEAAAAAAAAAAAAAAABAgxgPAAAAAAAAAAAAAAAAABrEeAAAAAAAAAAAAAAAAADQIMYDAAAAAAAAAAAAAAAAgAYxHgAAAAAAAAAAAAAAAAA0iPEAAAAAAAAAAAAAAAAAoEGMBwAAAAAAAAAAAAAAAAANYjwAAAAAAAAAAAAAAAAAaBDjAQAAAAAAAAAAAAAAAECDGA8AAAAAAAAAAAAAAAAAGsR4AAAAAAAAAAAAAAAAANAgxgMAAAAAAAAAAAAAAACABjEeAAAAAAAAAAAAAAAAADSI8QAAAAAAAAAAAAAAAACgQYwHAAAAAAAAAAAAAAAAAA1iPAAAAAAAAAAAAAAAAABoEOMBAAAAAAAAAAAAAAAAQIMYDwAAAAAA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)

## Project Goals & Business Relevance

<br>

Like most companies, Red Hat is able to gather a great deal of information over time about the behavior of individuals who interact with them. Theyre in search of better methods of using this behavioral data to predict which individuals they should approachand even when and how to approach them.

Our project goal is to accurately identify which Red Hat customers have the most potential business value for Red Hat based on their characteristics and activities.

The outcome of this work is to more efficiently prioritize resources to generate business and better serve their customers.

<br>


## Data Collection/Description

<br>

Red Hat provided two datasets for this project: a people file and an activity file. The people file contains all unique people in the data (along with corresponding characteristics), and the activity file contains data collected about their activities. The business value outcome is defined by the yes/no field attached to each unique activity that has been completed within a fixed window of time after each unique activity was performed. There are nine different activities joined to people using the shared person_id as the common key. All data is categorical with the exception of one feature (char_38) which is a continuous numerical variable.

<br>


## Getting Started with Google Colab and PySpark

<br>

### What is Spark?

Spark and, by extension, PySpark have gained a ton of popularity in recent years because of the power Spark provides to developers in working with big data sets efficiently. Spark is built to handle data as large as the Pedabyte scale, which is equivalent to 1,000,000 Gigabytes!

<br>

### How does it work?

[Spark](https://spark.apache.org/) is described by Apache (the maintainers of the tool) as, "a multi-language engine for executing data engineering, data science, and machine learning on single-node machines or clusters."


Basically, under the hood, Spark distributes the work you ask it to do to one or more workers ("nodes") which do their work separately, in parallel. They organize the steps they're supposed to take in a Directed Acyclic Graph, which is essentially a list of instructions for each worker to follow.


When each worker finishes the work they've been assigned, they come together at the end and combine all of the work they did separately. If you'd like to read more about how this process works in a more technical sense, I'd recommend reading [this StackOverflow answer and the articles they link to.](https://stackoverflow.com/a/54508672)

<br>

### Where does Python fit into all of this?

Spark is written in the Scala programming language, so it wasn't always possible to leverage the power of Spark unless you knew how to write code in Scala. More recently, Apache has made it possible to use Spark by writing code in Python, SQL, Scala, Java or R.

Python's application programming interface (API) for communicating with Spark is called PySpark, and can be a great tool to learn if you're someone who works with data.

<br>

### So what are we going to do?


##### *Preface: we'll be using [Google Colab](https://colab.research.google.com) for our data analysis to make it easier to download and use Spark. This will be an easier introduction than using your local machine, because you can avoid troubleshooting any installation issues you may encounter with getting Spark up and running on your unique device. Google Colab is free to use if you sign in with a Google account.*

<br>

As an introduction to using Spark, we're going to use it to do some data wrangling and basic machine-learning on the [RedHat dataset from Kaggle](https://www.kaggle.com/c/predicting-red-hat-business-value).

1. First, we'll upload the data into our Colab environment. Make sure the .zip files are downloaded onto your local machine from [Kaggle](https://www.kaggle.com/c/predicting-red-hat-business-value).
2. We'll unzip the .zip files so we can access the data using Python.
3. We'll join the act_train dataset with the people dataset on the "people_id" column.
4. We'll fill in missing values in the data.
5. We'll transform the String columns into numbers so that we can use the data with machine-learning models.
6. We'll fit a model from pyspark.ml to the data.
7. We'll make some predictions using the model.

##### *Note: if you see a code block that starts with an exclamation mark (!), that code block is a shell command. Shell and BASH are versions of the Linux command line that enable you to do tons of really cool stuff with your operating system like organizing files, searching for things, downloading files from the internet, networking, and anything else you can think of. Google Colab is running on Linux in the cloud, so we have to use Shell commands for some things.* 


```python
import os
from google.colab import files
```


```python
filenames = ["act_train.csv.zip", "act_test.csv.zip", "people.csv.zip", "sample_submission.csv.zip"]  # upload these
```


```python
path = "/home/colby/Downloads"
files.upload()  # tried to upload programmatically with "upload_file" method, colab disallows this.
```


    Saving people.csv.zip to people.csv.zip
    Saving act_train.csv.zip to act_train.csv.zip



```python
for filename in filenames:
  os.system("unzip {}".format(filename))
```


```python
!ls
```

    act_train.csv	   people.csv	   spark-3.3.1-bin-hadoop3
    act_train.csv.zip  people.csv.zip  spark-3.3.1-bin-hadoop3.tgz
    merged_train.csv   sample_data


### Pandas Comparison Section


```python
import numpy as np
import pandas as pd
```


```python
act_train = pd.read_csv("act_train.csv")
# act_test = pd.read_csv("act_test.csv")
people = pd.read_csv("people.csv")
merged = act_train.merge(people, on=["people_id"], how="inner")

del act_train
del people
```


```python
numerical_columns = ['people_id', 'activity_id', 'group_1', 'char_38', 'date_Day', 'activity_date_Day']
categorical_columns = ['activity_category']
for column in merged.columns:
    if column.startswith("char_") and column != "char_38":
        categorical_columns.append(column)
```


```python
categorical_columns
```




    ['activity_category',
     'char_1_x',
     'char_2_x',
     'char_3_x',
     'char_4_x',
     'char_5_x',
     'char_6_x',
     'char_7_x',
     'char_8_x',
     'char_9_x',
     'char_10_x',
     'char_1_y',
     'char_2_y',
     'char_3_y',
     'char_4_y',
     'char_5_y',
     'char_6_y',
     'char_7_y',
     'char_8_y',
     'char_9_y',
     'char_10_y',
     'char_11',
     'char_12',
     'char_13',
     'char_14',
     'char_15',
     'char_16',
     'char_17',
     'char_18',
     'char_19',
     'char_20',
     'char_21',
     'char_22',
     'char_23',
     'char_24',
     'char_25',
     'char_26',
     'char_27',
     'char_28',
     'char_29',
     'char_30',
     'char_31',
     'char_32',
     'char_33',
     'char_34',
     'char_35',
     'char_36',
     'char_37']




```python
merged = merged.drop_duplicates([i for i in merged.columns if i != "activity_id"])
date_ref = np.datetime64("2020-01-01")
merged['date_Day'] = pd.Series([i - date_ref for i in pd.to_datetime(merged.date_x)]).dt.days
merged['activity_date_Day'] = pd.Series([i - date_ref for i in pd.to_datetime(merged.date_y)]).dt.days
```


```python
for i in range(1, 11):
  merged['char_{}_x'.format(i)] = merged['char_{}_x'.format(i)].fillna('type 0')
```


```python
compare = False
if compare:
  for i, act_df in enumerate([act_train]):  # , act_test
    # Merge and clean the data, make it numeric for neural network training
    merged = act_df.merge(people, on=["people_id"], how="inner")
    merged = merged.drop_duplicates([i for i in merged.columns if i != "activity_id"])
    date_ref = np.datetime64("2020-01-01")
    merged['date_Day'] = pd.Series([i - date_ref for i in pd.to_datetime(merged.date_x)]).dt.days
    merged['activity_date_Day'] = pd.Series([i - date_ref for i in pd.to_datetime(merged.date_y)]).dt.days

    numerify = lambda x: x.split("_")[1]
    under_columns = ["people_id", "activity_id"]
    for column in under_columns:
        merged[column] = merged[column].apply(numerify)
        merged[column] = pd.to_numeric(merged[column])

    def numerify(x):
      if type(x) == float:
        return x
      elif type(x) == str:
        return float(x.split(" ")[1])

    # numerify = lambda x: x.split(" ")[1]
    space_columns = ["group_1", "activity_category"]
    for column in space_columns:
        merged[column] = merged[column].apply(numerify)
        merged[column] = pd.to_numeric(merged[column])

    boolean_numerify = lambda x: x/1
    for column in categorical_columns[1:]:
        try:
            num = int(column.split("_")[1])
        except:
            print(column)
            break
        if num < 10 or column == "char_10_x":
            merged[column].fillna("type 0.0", inplace=True)
            merged[column] = merged[column].apply(numerify)
            merged[column] = pd.to_numeric(merged[column])
        elif num >= 10:
            merged[column].fillna(-1.0, inplace=True)
            merged[column] = merged[column].apply(boolean_numerify)
        # print("{}:\n{}".format(column, merged[column].unique()))
    merged.to_csv("merge{}.csv".format(i), index=False)
```


```python
merged.to_csv("merged_train.csv", index=False)
```


```python
!ls
```

    act_train.csv	   people.csv	   spark-3.3.1-bin-hadoop3
    act_train.csv.zip  people.csv.zip  spark-3.3.1-bin-hadoop3.tgz
    merged_train.csv   sample_data



```python
merged = pd.read_csv("merged_train.csv")
```


```python
merged_train = merged
```

### Spark Installation

To work with Spark, we'll need a few things to be installed in our Colab environment:
1. PySpark (Python library for using Spark)
2. FindSpark (Python library for locating the computer resources / software required to start and talk to Spark)
3. Java Development Kit (JDK) to run Spark
4. Spark 3.3.1 from apache.org


```python
!pip install findspark pyspark
```

    Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/
    Collecting findspark
      Downloading findspark-2.0.1-py2.py3-none-any.whl (4.4 kB)
    Collecting pyspark
      Downloading pyspark-3.3.1.tar.gz (281.4 MB)
    [K     || 281.4 MB 43 kB/s 
    [?25hCollecting py4j==0.10.9.5
      Downloading py4j-0.10.9.5-py2.py3-none-any.whl (199 kB)
    [K     || 199 kB 60.8 MB/s 
    [?25hBuilding wheels for collected packages: pyspark
      Building wheel for pyspark (setup.py) ... [?25l[?25hdone
      Created wheel for pyspark: filename=pyspark-3.3.1-py2.py3-none-any.whl size=281845512 sha256=3b561b4e4a856905fe6f9364fa708ca730d2255d821a2556457dac95abdff5a2
      Stored in directory: /root/.cache/pip/wheels/43/dc/11/ec201cd671da62fa9c5cc77078235e40722170ceba231d7598
    Successfully built pyspark
    Installing collected packages: py4j, pyspark, findspark
    Successfully installed findspark-2.0.1 py4j-0.10.9.5 pyspark-3.3.1



```python
!apt-get install openjdk-8-jdk-headless -qq > /dev/null
```


```python
!wget -q https://dlcdn.apache.org/spark/spark-3.3.1/spark-3.3.1-bin-hadoop3.tgz
```


```python
!tar -xf spark-3.3.1-bin-hadoop3.tgz
```


```python
!ls /content/
```

    sample_data  spark-3.3.1-bin-hadoop3  spark-3.3.1-bin-hadoop3.tgz



```python
import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-11-openjdk-amd64"
os.environ["SPARK_HOME"] = "/content/spark-3.3.1-bin-hadoop3.tgz"
```


```python
# !sudo echo "spark.driver.memory 15g" > $SPARK_HOME/conf/spark-defaults.conf
# !cat $SPARK_HOME/conf/spark-defaults.conf
```


```python
import findspark
findspark.init("/content/spark-3.3.1-bin-hadoop3")
# from pyspark import SparkConf, SparkContext
# conf = SparkConf().setMaster("local[*]").setAppName("RedHat")
# sc = SparkContext(conf = conf)
#### These lines are to tell jupyter where to find Apache Spark ####
```


```python
from pyspark.sql import SparkSession
spark = SparkSession.builder.master("local[*]").config("spark.driver.memory", "12g").appName("RedHat").getOrCreate()  #.config(conf=SparkConf())
```


```python
subset = merged_train[numerical_columns + categorical_columns + ["outcome"]]
```


```python
# subset.columns = range(101)
# subset["target"] = merged_train["target"]
```


```python
df = spark.createDataFrame(subset)
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-12-64596b77effc> in <module>
    ----> 1 df = spark.createDataFrame(subset)
    

    NameError: name 'subset' is not defined



```python
from pyspark.sql.functions import col


act_train = spark.read.csv("act_train.csv", header=True) \
                .withColumnRenamed("char_1", "char_1_x") \
                .withColumnRenamed("char_2", "char_2_x") \
                .withColumnRenamed("char_3", "char_3_x") \
                .withColumnRenamed("char_4", "char_4_x") \
                .withColumnRenamed("char_5", "char_5_x") \
                .withColumnRenamed("char_6", "char_6_x") \
                .withColumnRenamed("char_7", "char_7_x") \
                .withColumnRenamed("char_8", "char_8_x") \
                .withColumnRenamed("char_9", "char_9_x") \
                .withColumnRenamed("char_10", "char_10_x") \
                .withColumnRenamed("date", "act_date")
people = spark.read.csv("people.csv", header=True)

duplicated_columns = []
for column in act_train.columns:
  if column in people.columns and column != "people_id":
    duplicated_columns.append(column)

# act_train = act_train.select(*(col(x).alias(x + '_act') for x in df1.columns))
# people = people.select(*(col(x).alias(x + '_act') for x in df1.columns))


duplicated_df = act_train.alias("x").join(people.alias("y"), on="people_id", how="inner")
```


```python
def rename_duplicate_columns(dataframe):
    columns = dataframe.columns
    duplicate_column_indices = list(set([columns.index(col) for col in columns if columns.count(col) == 2]))
    for index in duplicate_column_indices:
        columns[index] = columns[index]+'_2'
    dataframe = dataframe.toDF(*columns)
    return dataframe

numerical_columns = ['people_id', 'activity_id', 'group_1', 'char_38', 'date', 'act_date']
categorical_columns = ['activity_category']
for column in duplicated_df.columns:
    if column.startswith("char_") and column != "char_38":
        categorical_columns.append(column)
```


```python
df = rename_duplicate_columns(duplicated_df).select(numerical_columns + categorical_columns + ["outcome"])
```

### Basic EDA

Let's take a look at the basics of our dataset. How many rows do we have? How many columns?


```python
print((df.count(), len(df.columns)))
```

    (2197291, 55)



```python
df.columns
```




    ['people_id',
     'activity_id',
     'group_1',
     'char_38',
     'date',
     'act_date',
     'activity_category',
     'char_1_x',
     'char_2_x',
     'char_3_x',
     'char_4_x',
     'char_5_x',
     'char_6_x',
     'char_7_x',
     'char_8_x',
     'char_9_x',
     'char_10_x',
     'char_1',
     'char_2',
     'char_3',
     'char_4',
     'char_5',
     'char_6',
     'char_7',
     'char_8',
     'char_9',
     'char_10',
     'char_11',
     'char_12',
     'char_13',
     'char_14',
     'char_15',
     'char_16',
     'char_17',
     'char_18',
     'char_19',
     'char_20',
     'char_21',
     'char_22',
     'char_23',
     'char_24',
     'char_25',
     'char_26',
     'char_27',
     'char_28',
     'char_29',
     'char_30',
     'char_31',
     'char_32',
     'char_33',
     'char_34',
     'char_35',
     'char_36',
     'char_37',
     'outcome']



We might want to see if strong patterns exist between groups and outcome, so let's look at the breakdown of each group by outcome.

We can use a spark.sql to run a simple aggregate SQL query, which we can use to count the number of 1's and 0's in outcome per group.


```python
spark.sql("SELECT group_1, outcome, count(*) from {df} group by group_1, outcome", df=df).show()
```

    +-----------+-------+--------+
    |    group_1|outcome|count(1)|
    +-----------+-------+--------+
    | group 1482|      1|    3243|
    | group 5400|      0|     215|
    | group 1011|      1|     491|
    | group 1135|      1|      79|
    | group 1589|      1|     139|
    |  group 510|      1|     180|
    |group 48798|      1|       2|
    |group 10069|      1|     257|
    |group 31588|      0|      57|
    | group 4096|      1|     189|
    |group 41702|      1|      11|
    |group 38600|      0|      16|
    |group 25223|      1|     179|
    |group 18999|      0|     246|
    |  group 408|      1|      19|
    |group 34172|      1|       4|
    |group 44523|      0|      39|
    |group 39729|      1|      36|
    |group 32431|      0|       1|
    |group 26880|      1|      10|
    +-----------+-------+--------+
    only showing top 20 rows
    


Based on the numbers we have in the third column, it looks like the vast majority of rows belong to users who do not belong to any group!

We'll need to handle the missing data with some kind of imputation method.


```python
from pyspark.ml import Pipeline
from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler
from pyspark.ml.classification import LogisticRegression
```

Let's take a look at our Dataframe's "schema", which is just a breakdown of the Metadata of our Data: a description of what type of stuff is in each column.


```python
for i in df.schema:
  print(i)
```

    StructField('people_id', StringType(), True)
    StructField('activity_id', StringType(), True)
    StructField('group_1', StringType(), True)
    StructField('char_38', StringType(), True)
    StructField('date', StringType(), True)
    StructField('act_date', StringType(), True)
    StructField('activity_category', StringType(), True)
    StructField('char_1_x', StringType(), True)
    StructField('char_2_x', StringType(), True)
    StructField('char_3_x', StringType(), True)
    StructField('char_4_x', StringType(), True)
    StructField('char_5_x', StringType(), True)
    StructField('char_6_x', StringType(), True)
    StructField('char_7_x', StringType(), True)
    StructField('char_8_x', StringType(), True)
    StructField('char_9_x', StringType(), True)
    StructField('char_10_x', StringType(), True)
    StructField('char_1', StringType(), True)
    StructField('char_2', StringType(), True)
    StructField('char_3', StringType(), True)
    StructField('char_4', StringType(), True)
    StructField('char_5', StringType(), True)
    StructField('char_6', StringType(), True)
    StructField('char_7', StringType(), True)
    StructField('char_8', StringType(), True)
    StructField('char_9', StringType(), True)
    StructField('char_10', StringType(), True)
    StructField('char_11', StringType(), True)
    StructField('char_12', StringType(), True)
    StructField('char_13', StringType(), True)
    StructField('char_14', StringType(), True)
    StructField('char_15', StringType(), True)
    StructField('char_16', StringType(), True)
    StructField('char_17', StringType(), True)
    StructField('char_18', StringType(), True)
    StructField('char_19', StringType(), True)
    StructField('char_20', StringType(), True)
    StructField('char_21', StringType(), True)
    StructField('char_22', StringType(), True)
    StructField('char_23', StringType(), True)
    StructField('char_24', StringType(), True)
    StructField('char_25', StringType(), True)
    StructField('char_26', StringType(), True)
    StructField('char_27', StringType(), True)
    StructField('char_28', StringType(), True)
    StructField('char_29', StringType(), True)
    StructField('char_30', StringType(), True)
    StructField('char_31', StringType(), True)
    StructField('char_32', StringType(), True)
    StructField('char_33', StringType(), True)
    StructField('char_34', StringType(), True)
    StructField('char_35', StringType(), True)
    StructField('char_36', StringType(), True)
    StructField('char_37', StringType(), True)
    StructField('outcome', StringType(), True)


As you can see, there are a lot of columns. Many of them are strings, some are boolean, and some are numbers (long, double).

<br>

The basic overview of the data is that the data from the People dataset contains some data about the people present in both datasets. The Act_Train dataset contains data about what actions people performed on the RedHat website, and an "outcome" variable that represents whether or not they purchased something.

<br>

None of the column names or column data give us any clues regarding who people are, what actions they performed, or what the "outcome" variable represents, precisely.

If we were doing more serious long-term analysis, this would be a huge problem. Fortunately, we're just going to be using this data as an exercise in how to deal with large amounts of data using a new tool.

<br>

We'd like to fill in missing values, but first let's focus on converting all of the columns into numeric data.

<br>

### Type Conversions

Okay, so the String columns look something like this: 

group_id -> group_1, group_2, ... , group_10001 

OR like this:

char_1 -> type 1, type 7, ... , type 189

<br>

As you can tell, every String column has a number hidden within it, which we can extract using *lambda functions*.

for example, 
```
lambda x: int(x.split(" ")[1])
```
will turn the string "type 1" into the number 1.

<br>

If you've never used a lambda function before, definitely go look at [some tutorials](https://www.freecodecamp.org/news/python-lambda-function-explained/) on them because they'll be important for understanding and using Spark dataframes and RDDs.


```python
from pyspark.sql.types import StringType, BooleanType, DoubleType
from pyspark.sql.functions import col, udf

numerify_under_column = udf(lambda x: float(x.split("_")[1]), DoubleType())

numerify_space_column = udf(lambda x: float(x.split(" ")[1]), DoubleType())

numerify_boolean_column = udf(lambda x: x/1, DoubleType())

print("df", sep="")
for column in df.columns:
  sub = df.select(column).na.drop().take(1)
  # print(sub)
  if len(sub) > 0:
    example = sub[0]

    if df.schema[column].dataType == StringType():
      # print("Converting String column {}".format(column))
      # check to see whether the column looks like "type 1" or like "type_1"
      if "_" in example[column]:
        # df = df.withColumn(column, numerify_under_column(col(column)))
        print(".withColumn(\"{}\", numerify_under_column(col(\"{}\"))) \\".format(column, column), sep=" \\\n")

      else:
        # df = df.withColumn(column, numerify_space_column(col(column)))
        print(".withColumn(\"{}\", numerify_space_column(col(\"{}\"))) \\".format(column, column), sep=" \\\n")

    elif df.schema[column].dataType == BooleanType():
      # print("Converting Boolean column {}".format(column))
      # df = df.withColumn(column, numerify_boolean_column(col(column)))
      print(".withColumn(\"{}\", numerify_boolean_column(col(\"{}\"))) \\".format(column, column), sep=" \\\n")

```


```python
converted_df = df \
    .withColumn("people_id", numerify_under_column(col("people_id"))) \
    .withColumn("activity_id", numerify_under_column(col("activity_id"))) \
    .withColumn("group_1", numerify_space_column(col("group_1"))) \
    .withColumn("char_38", numerify_space_column(col("char_38"))) \
    .withColumn("activity_category", numerify_space_column(col("activity_category"))) \
    .withColumn("char_1_x", numerify_space_column(col("char_1_x"))) \
    .withColumn("char_2_x", numerify_space_column(col("char_2_x"))) \
    .withColumn("char_3_x", numerify_space_column(col("char_3_x"))) \
    .withColumn("char_4_x", numerify_space_column(col("char_4_x"))) \
    .withColumn("char_5_x", numerify_space_column(col("char_5_x"))) \
    .withColumn("char_6_x", numerify_space_column(col("char_6_x"))) \
    .withColumn("char_7_x", numerify_space_column(col("char_7_x"))) \
    .withColumn("char_8_x", numerify_space_column(col("char_8_x"))) \
    .withColumn("char_9_x", numerify_space_column(col("char_9_x"))) \
    .withColumn("char_10_x", numerify_space_column(col("char_10_x"))) \
    .withColumn("char_1", numerify_space_column(col("char_1"))) \
    .withColumn("char_2", numerify_space_column(col("char_2"))) \
    .withColumn("char_3", numerify_space_column(col("char_3"))) \
    .withColumn("char_4", numerify_space_column(col("char_4"))) \
    .withColumn("char_5", numerify_space_column(col("char_5"))) \
    .withColumn("char_6", numerify_space_column(col("char_6"))) \
    .withColumn("char_7", numerify_space_column(col("char_7"))) \
    .withColumn("char_8", numerify_space_column(col("char_8"))) \
    .withColumn("char_9", numerify_space_column(col("char_9"))) \
    .withColumn("char_10", numerify_space_column(col("char_10"))) \
    .withColumn("char_11", numerify_space_column(col("char_11"))) \
    .withColumn("char_12", numerify_space_column(col("char_12"))) \
    .withColumn("char_13", numerify_space_column(col("char_13"))) \
    .withColumn("char_14", numerify_space_column(col("char_14"))) \
    .withColumn("char_15", numerify_space_column(col("char_15"))) \
    .withColumn("char_16", numerify_space_column(col("char_16"))) \
    .withColumn("char_17", numerify_space_column(col("char_17"))) \
    .withColumn("char_18", numerify_space_column(col("char_18"))) \
    .withColumn("char_19", numerify_space_column(col("char_19"))) \
    .withColumn("char_20", numerify_space_column(col("char_20"))) \
    .withColumn("char_21", numerify_space_column(col("char_21"))) \
    .withColumn("char_22", numerify_space_column(col("char_22"))) \
    .withColumn("char_23", numerify_space_column(col("char_23"))) \
    .withColumn("char_24", numerify_space_column(col("char_24"))) \
    .withColumn("char_25", numerify_space_column(col("char_25"))) \
    .withColumn("char_26", numerify_space_column(col("char_26"))) \
    .withColumn("char_27", numerify_space_column(col("char_27"))) \
    .withColumn("char_28", numerify_space_column(col("char_28"))) \
    .withColumn("char_29", numerify_space_column(col("char_29"))) \
    .withColumn("char_30", numerify_space_column(col("char_30"))) \
    .withColumn("char_31", numerify_space_column(col("char_31"))) \
    .withColumn("char_32", numerify_space_column(col("char_32"))) \
    .withColumn("char_33", numerify_space_column(col("char_33"))) \
    .withColumn("char_34", numerify_space_column(col("char_34"))) \
    .withColumn("char_35", numerify_space_column(col("char_35"))) \
    .withColumn("char_36", numerify_space_column(col("char_36"))) \
    .withColumn("char_37", numerify_space_column(col("char_37")))
```

Let's take another look at our schema and see how we did!


```python
for i in converted_df.schema:
  print(i)
```

    StructField('people_id', DoubleType(), True)
    StructField('activity_id', DoubleType(), True)
    StructField('group_1', DoubleType(), True)
    StructField('char_38', DoubleType(), True)
    StructField('date', StringType(), True)
    StructField('act_date', StringType(), True)
    StructField('activity_category', DoubleType(), True)
    StructField('char_1_x', DoubleType(), True)
    StructField('char_2_x', DoubleType(), True)
    StructField('char_3_x', DoubleType(), True)
    StructField('char_4_x', DoubleType(), True)
    StructField('char_5_x', DoubleType(), True)
    StructField('char_6_x', DoubleType(), True)
    StructField('char_7_x', DoubleType(), True)
    StructField('char_8_x', DoubleType(), True)
    StructField('char_9_x', DoubleType(), True)
    StructField('char_10_x', DoubleType(), True)
    StructField('char_1', DoubleType(), True)
    StructField('char_2', DoubleType(), True)
    StructField('char_3', DoubleType(), True)
    StructField('char_4', DoubleType(), True)
    StructField('char_5', DoubleType(), True)
    StructField('char_6', DoubleType(), True)
    StructField('char_7', DoubleType(), True)
    StructField('char_8', DoubleType(), True)
    StructField('char_9', DoubleType(), True)
    StructField('char_10', DoubleType(), True)
    StructField('char_11', DoubleType(), True)
    StructField('char_12', DoubleType(), True)
    StructField('char_13', DoubleType(), True)
    StructField('char_14', DoubleType(), True)
    StructField('char_15', DoubleType(), True)
    StructField('char_16', DoubleType(), True)
    StructField('char_17', DoubleType(), True)
    StructField('char_18', DoubleType(), True)
    StructField('char_19', DoubleType(), True)
    StructField('char_20', DoubleType(), True)
    StructField('char_21', DoubleType(), True)
    StructField('char_22', DoubleType(), True)
    StructField('char_23', DoubleType(), True)
    StructField('char_24', DoubleType(), True)
    StructField('char_25', DoubleType(), True)
    StructField('char_26', DoubleType(), True)
    StructField('char_27', DoubleType(), True)
    StructField('char_28', DoubleType(), True)
    StructField('char_29', DoubleType(), True)
    StructField('char_30', DoubleType(), True)
    StructField('char_31', DoubleType(), True)
    StructField('char_32', DoubleType(), True)
    StructField('char_33', DoubleType(), True)
    StructField('char_34', DoubleType(), True)
    StructField('char_35', DoubleType(), True)
    StructField('char_36', DoubleType(), True)
    StructField('char_37', DoubleType(), True)
    StructField('outcome', DoubleType(), True)


Amazing, now all of our data is numeric, which should make fitting a machine-learning model way simpler than all of the Strings and Boolean values we had before.

### Minimum Values & Missing Values

The act_train dataset has tons of missing values, and the data as a whole consists of Strings and Boolean (True/False) values that aren't compatible with many machine-learning models, so we'll need to do some data exploration and wrangling before we proceed.

We're going to fill in missing values with the minimum value of each column - 1.

Let's start by getting the minimum value of each column! This will tell us about the format of the column and what value we'll need to use instead of NaN.


```python
mins = {}
for column in converted_df.columns:
  mins[column] = converted_df.agg({column: 'min'}).take(1).pop().asDict()["min({})".format(column)]
```


```python
mins
```

For some columns, the minimum column value is 1, but in other cases it's far from 1, like 138, or 928. If we want to fit a model like a neural network, we'll need data to be on roughly the same scale across columns, and we can't have missing values. We'll need to fill missing values in.

We want the stand-in value that we replace NaNs with to be distinct from other values in the column, so we'll set it to min(column)-1 for now.


```python
fill_vals = {}
for key in mins.keys():
  fill_vals[key] = mins[key] - 1.0

```


```python
df.na.fill(fill_vals)
```


```python
unlimited_memory = False
if unlimited_memory:
  input_cols = [col for col in df.columns if col != "outcome"]
  output_cols = ["{}_one_hot".format(col) for col in df.columns if col != "outcome"]

  one_hot_encoder = OneHotEncoder()
  one_hot_encoder.setInputCols(input_cols)
  one_hot_encoder.setOutputCols(output_cols)
  model = one_hot_encoder.fit(df.na.fill(fill_vals))
  model.setOutputCols(output_cols)
  model.transform(df.na.fill(fill_vals)).head().output
```

Too much memory is required to build a one-hot encoded dataframe using the unique values of every column in the dataframe. Instead, maybe we can use the X most common values of each column and use those to create a one-hot encoded dataset.

Alternatively, we might be able to train a model on what we have now and not worry so much about one-hot encoding the data.

### Fitting a basic model

Because the outcome variable we're going to predict is binary (only 0 or 1), we can fit a logistic regression to the data as a good first model. Logistic Regressions are meant to deal with binary data. They are not, however, good at dealing with non-linear data. Because our data was a bunch of categories before we performed our transformations, I don't think Logistic Regression will fare particularly well here.

Later, we'll be able to swap our the logistic regression model for a non-linear model without much trouble, so it's not expensive to experiment here.

Also, we'll be using a CrossValidator class from pyspark.ml to make sure the model we train performs well on unseen data.

To fit our model, we'll need to transform our dataframe such that the features of each row are all in one vector called "features",

Also, pyspark models expect the outcome variable to be named "label", so we'll use 
```
df.withColumnRenamed('old_name', 'new_name')
```
to rename outcome to target.


```python
from pyspark.ml.feature import VectorAssembler
from pyspark.ml.evaluation import BinaryClassificationEvaluator
from pyspark.ml import Pipeline
from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
from pyspark.ml.classification import LogisticRegression

logistic_regression = LogisticRegression()
logistic_regression.setRegParam(0.01)
logistic_regression.setMaxIter(10)

grid = ParamGridBuilder().addGrid(logistic_regression.maxIter, [0, 1]).build()
evaluator = BinaryClassificationEvaluator()
cv = CrossValidator(estimator=logistic_regression, estimatorParamMaps=grid, evaluator=evaluator, parallelism=2)

feature_assembler = VectorAssembler(inputCols=[column for column in converted_df.columns if column != "outcome"], outputCol="features", handleInvalid = "keep")
```


```python
fitted_model = cv.fit(feature_assembler.transform(converted_df.na.fill(fill_vals).withColumnRenamed("outcome", "label")))
```


```python
fitted_model.avgMetrics
```

As you should be able to see, the logistic regression accurately classifies roughly 78% of data points using three-fold cross validation.


```python
fitted_model.params
```


```python
prediction = fitted_model.transform(spark.createDataFrame(feature_assembler.transform(converted_df.na.fill(fill_vals).withColumnRenamed("outcome", "label")).take(10)))
selected = prediction.select("label", "probability", "prediction")
for row in selected.collect():
    label, prob, prediction = row
    print(label, prob, prediction)
```

### PySpark Caveats

<br>

#### Underdeveloped

Admittedly, PySpark's Machine Learning ecosystem feels premature at times. Some tasks which are relatively simple using libraries like Pandas (e.g., joining two dataframes, computing metrics, renaming columns, dropping rows, filling missing values, splitting the data) are done differently and sometimes, (in my opinion) in less intuitive ways. The same is true for building, fitting, and evaluating models with libraries like sklearn, tensorflow, etc. when compared with the pyspark.ml library.

Of course, this could simply be due to the massive differential (currently) in people using Pandas, Sklearn, Tensorflow, etc. compared to the current users of PySpark as a library. This imbalance in popularity certainly contributes to the underdevelopment of one when compared with the other.

*Understand too, that PySpark's dataframes are a high-level abstraction built on top of Resilient Distributed Datasets (RDDs). This structure comes with some quirks to make all of the performance improvements work*

<br>

#### Underpowered at a Local Level

The other thing that goes against PySpark's wide-spread adoption is the fact that when working with data using resources comparable to a local development environment (16 GB of Ram or less, average CPU), using PySpark feels no more efficient for handling data tasks than using something like Pandas. In fact, Spark running on your laptop may be significantly slower than using Pandas, depending on the task.

The great benefit of Spark (and PySpark) is that you can scale your data processing to huge datasets. The drawback is that you need to be operating with huge data to realize how important this quality truly is.

Anyone that is learning about data science or hasn't stumbled across a data set where they absolutely could not use it locally probably won't see the value in using something like Spark. 

You have to hit that barrier head-first to realize how beneficial a distributed programming tool really can be.

#### TL;DR

Don't feel discouraged or confused if you don't immediately see the value of Spark as a tool if your only exposure is this report.

##Conclusion

Now that you've gotten your feet wet with PySpark, hopefully you can see a little bit into how the API handles, the conventions, and how to approach many of the basic tasks you might want to perform when dealing with a data set (e.g., looking at value counts, finding the minimum value of a column, filling in missing data, fitting a model, and making predictions)

Overall, it is a very valuable tool for handling big data and scales much better as data grows in size than its vanilla Python counterparts.

## Another Approach - Naive Numerical Conversion (Using Pandas)


```python
import pandas as pd
import numpy as np
```


```python
act_train = pd.read_csv("act_train.csv", parse_dates=["date"])
people = pd.read_csv("people.csv")
```

#### Examining the data

There are a lot of missing values in the act_train data, but none in the people data. None of the columns provide very much insight into who any of the people are, or what they're doing. We'll just have to clean things up the best way we can by going through all of the basics: removing or filling null values, figuring out which columns are categorical (just a few unique values) or continuous (mostly unique values), and train some models from there!


```python
act_train.head()
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>people_id</th>
      <th>activity_id</th>
      <th>date</th>
      <th>activity_category</th>
      <th>char_1</th>
      <th>char_2</th>
      <th>char_3</th>
      <th>char_4</th>
      <th>char_5</th>
      <th>char_6</th>
      <th>char_7</th>
      <th>char_8</th>
      <th>char_9</th>
      <th>char_10</th>
      <th>outcome</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ppl_100</td>
      <td>act2_1734928</td>
      <td>2023-08-26</td>
      <td>type 4</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>type 76</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ppl_100</td>
      <td>act2_2434093</td>
      <td>2022-09-27</td>
      <td>type 2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>type 1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ppl_100</td>
      <td>act2_3404049</td>
      <td>2022-09-27</td>
      <td>type 2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>type 1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ppl_100</td>
      <td>act2_3651215</td>
      <td>2023-08-04</td>
      <td>type 2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>type 1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ppl_100</td>
      <td>act2_4109017</td>
      <td>2023-08-26</td>
      <td>type 2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>type 1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>


```python
people.head()
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>people_id</th>
      <th>char_1</th>
      <th>group_1</th>
      <th>char_2</th>
      <th>date</th>
      <th>char_3</th>
      <th>char_4</th>
      <th>char_5</th>
      <th>char_6</th>
      <th>char_7</th>
      <th>...</th>
      <th>char_29</th>
      <th>char_30</th>
      <th>char_31</th>
      <th>char_32</th>
      <th>char_33</th>
      <th>char_34</th>
      <th>char_35</th>
      <th>char_36</th>
      <th>char_37</th>
      <th>char_38</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ppl_100</td>
      <td>type 2</td>
      <td>group 17304</td>
      <td>type 2</td>
      <td>2021-06-29</td>
      <td>type 5</td>
      <td>type 5</td>
      <td>type 5</td>
      <td>type 3</td>
      <td>type 11</td>
      <td>...</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>36</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ppl_100002</td>
      <td>type 2</td>
      <td>group 8688</td>
      <td>type 3</td>
      <td>2021-01-06</td>
      <td>type 28</td>
      <td>type 9</td>
      <td>type 5</td>
      <td>type 3</td>
      <td>type 11</td>
      <td>...</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>76</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ppl_100003</td>
      <td>type 2</td>
      <td>group 33592</td>
      <td>type 3</td>
      <td>2022-06-10</td>
      <td>type 4</td>
      <td>type 8</td>
      <td>type 5</td>
      <td>type 2</td>
      <td>type 5</td>
      <td>...</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>99</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ppl_100004</td>
      <td>type 2</td>
      <td>group 22593</td>
      <td>type 3</td>
      <td>2022-07-20</td>
      <td>type 40</td>
      <td>type 25</td>
      <td>type 9</td>
      <td>type 4</td>
      <td>type 16</td>
      <td>...</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>76</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ppl_100006</td>
      <td>type 2</td>
      <td>group 6534</td>
      <td>type 3</td>
      <td>2022-07-27</td>
      <td>type 40</td>
      <td>type 25</td>
      <td>type 9</td>
      <td>type 3</td>
      <td>type 8</td>
      <td>...</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>84</td>
    </tr>
  </tbody>
</table>
<p>5 rows  41 columns</p>


```python
print("The Act Train dataset has {} rows".format(act_train.shape[0]))
```

    The Act Train dataset has 2197291 rows



```python
act_train = act_train.drop(["activity_id"], axis=1).drop_duplicates()
```


```python
print("The Act Train dataset has {} rows without duplicates".format(act_train.shape[0]))
```

    The Act Train dataset has 1213878 rows without duplicates



```python
# How many rows are there per person (without duplicates?)
# This code may take a very long time to run, be warned!
run_this_long_code_block = False
if run_this_long_code_block:
  frequencies = []
  persons = act_train.people_id.unique()
  print("Finding frequencies for {} unique persons".format(len(persons)))
  done = 0
  for person in persons:
      print("{} remaining".format(len(persons)-done))
      occurrences = act_train[act_train["people_id"] == person].shape[0]
      frequencies.append(occurrences)
  pd.Series(frequencies).describe()
```

```
count    151295.000000
mean          8.023253
std          15.148677
min           1.000000
25%           2.000000
50%           3.000000
75%           7.000000
max        1088.000000
```

### Missing Data

How much of each of our columns is filled with Null values?


```python
for column in act_train.columns:
    print("{} -> {}%".format(column, act_train[column].isna().sum()/act_train.shape[0]))
```

    people_id -> 0.0%
    date -> 0.0%
    activity_category -> 0.0%
    char_1 -> 0.8892392810480131%
    char_2 -> 0.8892392810480131%
    char_3 -> 0.8892392810480131%
    char_4 -> 0.8892392810480131%
    char_5 -> 0.8892392810480131%
    char_6 -> 0.8892392810480131%
    char_7 -> 0.8892392810480131%
    char_8 -> 0.8892392810480131%
    char_9 -> 0.8892392810480131%
    char_10 -> 0.11076071895198694%
    outcome -> 0.0%


It turns out that lots of our columns in act_train contain a LOT of missing data, almost 90%.

### Merging the datasets

We'll want data in both the people dataset and act train dataset for training our models, so let's merge them together.


```python
merged = act_train.merge(people, on=["people_id"], how="inner")
```

#### Unique Values & Data Formats

Although many of our columns are Strings, or "Objects" in pandas, we'd like to know specifically how each column's values look to get a better idea of what to do with the data before we can do any machine learning or prediction.

Let's look at how many unique values are in each column and what the first two values look like.


```python
for col, count in [(column, len(merged[column].unique())) for column in merged.columns]:
    print("{} has {} unique values".format(col, count))
    print(merged[col].unique()[:2])
```

    people_id has 151295 unique values
    ['ppl_100' 'ppl_100002']
    date_x has 411 unique values
    ['2023-08-26T00:00:00.000000000' '2022-09-27T00:00:00.000000000']
    activity_category has 7 unique values
    ['type 4' 'type 2']
    char_1_x has 52 unique values
    [nan 'type 3']
    char_2_x has 33 unique values
    [nan 'type 5']
    char_3_x has 12 unique values
    [nan 'type 1']
    char_4_x has 8 unique values
    [nan 'type 1']
    char_5_x has 8 unique values
    [nan 'type 6']
    char_6_x has 6 unique values
    [nan 'type 3']
    char_7_x has 9 unique values
    [nan 'type 3']
    char_8_x has 19 unique values
    [nan 'type 6']
    char_9_x has 20 unique values
    [nan 'type 8']
    char_10_x has 6516 unique values
    ['type 76' 'type 1']
    outcome has 2 unique values
    [0 1]
    char_1_y has 2 unique values
    ['type 2' 'type 1']
    group_1 has 29899 unique values
    ['group 17304' 'group 8688']
    char_2_y has 3 unique values
    ['type 2' 'type 3']
    date_y has 1196 unique values
    ['2021-06-29' '2021-01-06']
    char_3_y has 43 unique values
    ['type 5' 'type 28']
    char_4_y has 25 unique values
    ['type 5' 'type 9']
    char_5_y has 9 unique values
    ['type 5' 'type 9']
    char_6_y has 7 unique values
    ['type 3' 'type 2']
    char_7_y has 25 unique values
    ['type 11' 'type 5']
    char_8_y has 8 unique values
    ['type 2' 'type 3']
    char_9_y has 9 unique values
    ['type 2' 'type 4']
    char_10_y has 2 unique values
    [ True False]
    char_11 has 2 unique values
    [False  True]
    char_12 has 2 unique values
    [False  True]
    char_13 has 2 unique values
    [ True False]
    char_14 has 2 unique values
    [ True False]
    char_15 has 2 unique values
    [False  True]
    char_16 has 2 unique values
    [ True False]
    char_17 has 2 unique values
    [False  True]
    char_18 has 2 unique values
    [False  True]
    char_19 has 2 unique values
    [False  True]
    char_20 has 2 unique values
    [False  True]
    char_21 has 2 unique values
    [ True False]
    char_22 has 2 unique values
    [False  True]
    char_23 has 2 unique values
    [False  True]
    char_24 has 2 unique values
    [False  True]
    char_25 has 2 unique values
    [False  True]
    char_26 has 2 unique values
    [False  True]
    char_27 has 2 unique values
    [ True False]
    char_28 has 2 unique values
    [ True False]
    char_29 has 2 unique values
    [False  True]
    char_30 has 2 unique values
    [ True False]
    char_31 has 2 unique values
    [ True False]
    char_32 has 2 unique values
    [False  True]
    char_33 has 2 unique values
    [False  True]
    char_34 has 2 unique values
    [ True False]
    char_35 has 2 unique values
    [ True False]
    char_36 has 2 unique values
    [ True False]
    char_37 has 2 unique values
    [False  True]
    char_38 has 101 unique values
    [36 76]


### Converting Data to Numeric

Our data won't be particularly useful if it's stuck in text format. We'll need to convert it to numeric so that we can fit a model to it.


```python
date_ref = np.datetime64("2020-01-01")
merged['date_Day'] = pd.Series([i - date_ref for i in merged.date_x]).dt.days
merged['activity_date_Day'] = pd.Series([i - date_ref for i in pd.to_datetime(merged.date_y)]).dt.days
merged[['date_x','date_Day', 'date_y', 'activity_date_Day']]
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>date_x</th>
      <th>date_Day</th>
      <th>date_y</th>
      <th>activity_date_Day</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2023-08-26</td>
      <td>1333</td>
      <td>2021-06-29</td>
      <td>545</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2022-09-27</td>
      <td>1000</td>
      <td>2021-06-29</td>
      <td>545</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2023-08-04</td>
      <td>1311</td>
      <td>2021-06-29</td>
      <td>545</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2023-08-26</td>
      <td>1333</td>
      <td>2021-06-29</td>
      <td>545</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2023-08-04</td>
      <td>1311</td>
      <td>2021-06-29</td>
      <td>545</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1213873</th>
      <td>2023-06-15</td>
      <td>1261</td>
      <td>2023-01-06</td>
      <td>1101</td>
    </tr>
    <tr>
      <th>1213874</th>
      <td>2023-07-14</td>
      <td>1290</td>
      <td>2023-01-06</td>
      <td>1101</td>
    </tr>
    <tr>
      <th>1213875</th>
      <td>2023-01-13</td>
      <td>1108</td>
      <td>2023-01-06</td>
      <td>1101</td>
    </tr>
    <tr>
      <th>1213876</th>
      <td>2023-03-30</td>
      <td>1184</td>
      <td>2023-01-06</td>
      <td>1101</td>
    </tr>
    <tr>
      <th>1213877</th>
      <td>2023-05-02</td>
      <td>1217</td>
      <td>2023-01-06</td>
      <td>1101</td>
    </tr>
  </tbody>
</table>
<p>1213878 rows  4 columns</p>
</div>


```python
# Some of the columns have a people_100 format, so we'll remove the 'people_'
under_columns = ["people_id"]
for column in under_columns:
    merged[column] = merged[column].apply(lambda x: x.split("_")[1])
    merged[column] = pd.to_numeric(merged[column])
```


```python
# Some of the columns have a group 100 format, so we'll remove the 'group '
space_columns = ["group_1", "activity_category"]
for column in space_columns:
    merged[column] = merged[column].apply(lambda x: x.split(" ")[1])
    merged[column] = pd.to_numeric(merged[column])
```


```python
# Let's put all of the columns which look like categorical data into one array
categorical_columns = ["activity_category"]
numerical_columns = ['people_id', 'activity_id', 'group_1', 'char_38', 'date_Day', 'activity_date_Day']
for column in merged.columns:
    if column.startswith("char_") and column != "char_38":
        categorical_columns.append(column)
```


```python
"""
This code block might look confusing.
Essentially, we're going to fill in missing values with something that looks
like the data currently in each column, and then convert the entire column to
numeric values using lambda functions.

It's okay if you don't understand everything that's going on.
"""


for column in categorical_columns[1:]:
    try:
        num = int(column.split("_")[1])
    except:
        print(column)
        break
    if num < 10 or column == "char_10_x":
        merged[column].fillna("type 0.0", inplace=True)
        merged[column] = merged[column].apply(lambda x: x.split(" ")[1])
        merged[column] = pd.to_numeric(merged[column])
    elif num >= 10:
        merged[column].fillna(-1.0, inplace=True)
        merged[column] = merged[column].apply(lambda x: x/1)
    print("{}:\n{}".format(column, merged[column].unique()))
```

    char_1_x:
    [ 0.  3. 36. 24.  2.  5. 12. 23.  7.  1. 10. 29.  8. 16. 26. 15. 17. 13.
     41. 11.  9. 25.  6.  4. 19. 20. 30. 14. 28. 22. 35. 40. 33. 43. 18. 27.
     39. 32. 47. 31. 38. 42. 34. 21. 49. 46. 37. 44. 50. 48. 52. 45.]
    char_2_x:
    [ 0.  5. 11.  6.  2.  1. 16. 14.  4.  8.  3. 10. 25. 26.  9. 19. 13.  7.
     12. 29. 17. 15. 18. 20. 21. 24. 22. 27. 23. 28. 31. 32. 30.]
    char_3_x:
    [ 0.  1.  5.  6.  3.  7.  8.  4.  9.  2. 10. 11.]
    char_4_x:
    [0. 1. 3. 2. 4. 6. 5. 7.]
    char_5_x:
    [0. 6. 1. 5. 2. 4. 3. 7.]
    char_6_x:
    [0. 3. 1. 2. 4. 5.]
    char_7_x:
    [0. 3. 1. 4. 2. 5. 6. 7. 8.]
    char_8_x:
    [ 0.  6.  4.  5.  9. 18. 14.  7.  3.  8. 11.  1. 13. 10. 15.  2. 16. 12.
     17.]
    char_9_x:
    [ 0.  8.  1.  2.  7. 13.  9. 15.  4.  6.  3. 12. 10. 17. 18. 14.  5. 16.
     19. 11.]
    char_10_x:
    [7.600e+01 1.000e+00 1.727e+03 ... 7.356e+03 6.865e+03 7.379e+03]
    char_1_y:
    [2 1]
    char_2_y:
    [2 3 1]
    char_3_y:
    [ 5 28  4 40 14  7 10  6 11  1  2  9  8 12 21 17 27 29 15 19 16 18  3 26
     31 20 23 24 39 30 13 38 35 32 22 25 36 33 37 34 41 44 42]
    char_4_y:
    [ 5  9  8 25  6  7 10 12  2  1  3  4 15 13 18 16 19 14 11 21 22 17 23 24
     20]
    char_5_y:
    [5 9 4 8 7 6 2 1 3]
    char_6_y:
    [3 2 1 4 6 5 7]
    char_7_y:
    [11  5  8  7  9 20  2 17 23  1  6  3 13 10 14 21 15 24 18 12 22  4 16 19
     25]
    char_8_y:
    [2 3 6 8 5 4 7 1]
    char_9_y:
    [2 4 3 6 8 5 9 7 1]
    char_10_y:
    [1. 0.]
    char_11:
    [0. 1.]
    char_12:
    [0. 1.]
    char_13:
    [1. 0.]
    char_14:
    [1. 0.]
    char_15:
    [0. 1.]
    char_16:
    [1. 0.]
    char_17:
    [0. 1.]
    char_18:
    [0. 1.]
    char_19:
    [0. 1.]
    char_20:
    [0. 1.]
    char_21:
    [1. 0.]
    char_22:
    [0. 1.]
    char_23:
    [0. 1.]
    char_24:
    [0. 1.]
    char_25:
    [0. 1.]
    char_26:
    [0. 1.]
    char_27:
    [1. 0.]
    char_28:
    [1. 0.]
    char_29:
    [0. 1.]
    char_30:
    [1. 0.]
    char_31:
    [1. 0.]
    char_32:
    [0. 1.]
    char_33:
    [0. 1.]
    char_34:
    [1. 0.]
    char_35:
    [1. 0.]
    char_36:
    [1. 0.]
    char_37:
    [0. 1.]


#### Subseting the data

We'll want to include only the columns which we converted to numbers so that the model doesn't encounter any weird values it doesn't understand.


```python
numerical_columns.remove("activity_id")
X_full = merged[categorical_columns + numerical_columns]
y_full = merged["outcome"]
```

### Scaling the Data

We're going to be using a machine-learning model called a *neural network* in the next section, so we don't want our columns to all be on vastly different scales.

Currently, in our data, some of the columns have huge numbers in them, and others only have a few smaller numbers in them. Leaving the data like this will sometimes result in problems training a neural network, like *exploding gradients*.

If we put everything on the same scale (between 0 and 1) using a process called *normalization*, we'll be in a much better position to start training the model.


```python
X_full = (X_full-X_full.min())/(X_full.max()-X_full.min())
```

### Splitting the Data into a Training Set and a Testing Set

To validate our model, we'll want to be able to see how well it performs when predicting "outcome" on data it's never seen before. So, we'll remove part of the data from the training and save it for the end, after we've fit the model.


```python
from sklearn.model_selection import train_test_split
X_inter, X_test, y_inter, y_test = train_test_split(X_full, y_full, train_size=0.8, stratify=y_full)
X_train, X_valid, y_train, y_valid = train_test_split(X_inter, y_inter, train_size=0.75, stratify=y_inter)
```

### Fitting the Neural Network

We'll be using a library called Keras to build and train a neural network on the data, now that we've done some preprocessing.

The data we're dealing with is categorical in nature which makes me think we'll need a model like a deep neural network to find all of the nonlinear relationships present in the data to make great predictions.


```python
from keras.models import Sequential
from keras.layers import Dense

#### Design the deep neural network [Small + 1 layer]
model = Sequential()
model.add(Dense(512, input_dim=X_train.shape[1], activation="relu"))
model.add(Dense(512, activation="relu"))

#### activation = sigmoid for binary classification
model.add(Dense(1, activation = "sigmoid"))

model.compile(optimizer="Adam", loss="binary_crossentropy", metrics=["accuracy"])
history = model.fit(X_train, y_train, validation_data=(X_valid,y_valid), epochs=25, batch_size=64, verbose=2)
```

    Epoch 1/25
    11381/11381 - 40s - loss: 0.3236 - accuracy: 0.8440 - val_loss: 0.2843 - val_accuracy: 0.8662 - 40s/epoch - 3ms/step
    Epoch 2/25
    11381/11381 - 35s - loss: 0.2654 - accuracy: 0.8756 - val_loss: 0.2433 - val_accuracy: 0.8869 - 35s/epoch - 3ms/step
    Epoch 3/25
    11381/11381 - 33s - loss: 0.2337 - accuracy: 0.8926 - val_loss: 0.2234 - val_accuracy: 0.8983 - 33s/epoch - 3ms/step
    Epoch 4/25
    11381/11381 - 37s - loss: 0.2103 - accuracy: 0.9046 - val_loss: 0.2040 - val_accuracy: 0.9089 - 37s/epoch - 3ms/step
    Epoch 5/25
    11381/11381 - 37s - loss: 0.1923 - accuracy: 0.9139 - val_loss: 0.1946 - val_accuracy: 0.9148 - 37s/epoch - 3ms/step
    Epoch 6/25
    11381/11381 - 32s - loss: 0.1780 - accuracy: 0.9211 - val_loss: 0.1842 - val_accuracy: 0.9193 - 32s/epoch - 3ms/step
    Epoch 7/25
    11381/11381 - 38s - loss: 0.1661 - accuracy: 0.9273 - val_loss: 0.1739 - val_accuracy: 0.9255 - 38s/epoch - 3ms/step
    Epoch 8/25
    11381/11381 - 37s - loss: 0.1558 - accuracy: 0.9321 - val_loss: 0.1710 - val_accuracy: 0.9269 - 37s/epoch - 3ms/step
    Epoch 9/25
    11381/11381 - 32s - loss: 0.1478 - accuracy: 0.9367 - val_loss: 0.1608 - val_accuracy: 0.9324 - 32s/epoch - 3ms/step
    Epoch 10/25
    11381/11381 - 36s - loss: 0.1400 - accuracy: 0.9402 - val_loss: 0.1537 - val_accuracy: 0.9364 - 36s/epoch - 3ms/step
    Epoch 11/25
    11381/11381 - 33s - loss: 0.1339 - accuracy: 0.9435 - val_loss: 0.1499 - val_accuracy: 0.9386 - 33s/epoch - 3ms/step
    Epoch 12/25
    11381/11381 - 33s - loss: 0.1278 - accuracy: 0.9462 - val_loss: 0.1555 - val_accuracy: 0.9368 - 33s/epoch - 3ms/step
    Epoch 13/25
    11381/11381 - 33s - loss: 0.1234 - accuracy: 0.9484 - val_loss: 0.1509 - val_accuracy: 0.9406 - 33s/epoch - 3ms/step
    Epoch 14/25
    11381/11381 - 37s - loss: 0.1187 - accuracy: 0.9509 - val_loss: 0.1420 - val_accuracy: 0.9446 - 37s/epoch - 3ms/step
    Epoch 15/25
    11381/11381 - 36s - loss: 0.1136 - accuracy: 0.9529 - val_loss: 0.1421 - val_accuracy: 0.9451 - 36s/epoch - 3ms/step
    Epoch 16/25
    11381/11381 - 36s - loss: 0.1106 - accuracy: 0.9544 - val_loss: 0.1414 - val_accuracy: 0.9447 - 36s/epoch - 3ms/step
    Epoch 17/25
    11381/11381 - 36s - loss: 0.1072 - accuracy: 0.9559 - val_loss: 0.1372 - val_accuracy: 0.9479 - 36s/epoch - 3ms/step
    Epoch 18/25
    11381/11381 - 32s - loss: 0.1038 - accuracy: 0.9577 - val_loss: 0.1373 - val_accuracy: 0.9484 - 32s/epoch - 3ms/step
    Epoch 19/25
    11381/11381 - 32s - loss: 0.1007 - accuracy: 0.9594 - val_loss: 0.1366 - val_accuracy: 0.9502 - 32s/epoch - 3ms/step
    Epoch 20/25
    11381/11381 - 33s - loss: 0.0983 - accuracy: 0.9602 - val_loss: 0.1360 - val_accuracy: 0.9496 - 33s/epoch - 3ms/step
    Epoch 21/25
    11381/11381 - 32s - loss: 0.0957 - accuracy: 0.9613 - val_loss: 0.1306 - val_accuracy: 0.9515 - 32s/epoch - 3ms/step
    Epoch 22/25
    11381/11381 - 36s - loss: 0.0934 - accuracy: 0.9623 - val_loss: 0.1311 - val_accuracy: 0.9521 - 36s/epoch - 3ms/step
    Epoch 23/25
    11381/11381 - 37s - loss: 0.0907 - accuracy: 0.9636 - val_loss: 0.1337 - val_accuracy: 0.9522 - 37s/epoch - 3ms/step
    Epoch 24/25
    11381/11381 - 32s - loss: 0.0889 - accuracy: 0.9644 - val_loss: 0.1271 - val_accuracy: 0.9556 - 32s/epoch - 3ms/step
    Epoch 25/25
    11381/11381 - 32s - loss: 0.0864 - accuracy: 0.9654 - val_loss: 0.1298 - val_accuracy: 0.9555 - 32s/epoch - 3ms/step


#### Loss of the model over training

Let's take a look at how the model's loss function performed over time. As we train the model, we hope that the loss (penalty given to the model for mistakes) will decrease for both training data, and testing data.


```python
import matplotlib.pyplot as plt
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title("Model's Training & Validation loss across epochs")
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()
```


    
![png](AML_files/AML_105_0.png)
    


Success! the model's loss consistently improves over the epochs, in both training and validation data.

#### Accuracy of the model over training

As we train the model, we also hope that it's accuracy in predictions will increase. How did the model fare over time?


```python
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title("Model's Training & Validation Accuracy across epochs")
plt.ylabel('Accuracy')
plt.xlabel('Epochs')
plt.legend(['Train', 'Validation'], loc='lower right')
plt.show()
```


    
![png](AML_files/AML_108_0.png)
    


Accuracy improves as we train, even on unseen data. This is exactly what we were hoping to see.

### Evaluating the Model

How well did the model learn the task? (Predicting which RedHat site visitors will become customers)

#### Accuracy

We'll have the model predict on each of the test entries and see how accurate it is.


```python
model.evaluate(X_test, y_test)
```

    7587/7587 [==============================] - 16s 2ms/step - loss: 0.1304 - accuracy: 0.9548





    [0.13041287660598755, 0.9548060894012451]



On the holdout data, the model is 95.5% accurate at separating customers from other site visitors, it seems like we've got ourselves a decent model.

#### AUC

What about [area under the receiver operating characteristic curve](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc)?

AUC is an important metric that is frequently used for measuring how successful a model is at distinguishing between positive and negative outcomes in a binary-classification problem.

The closer the AUC is to 1, the better the model is; the closer to 0.5, the worse the model is.


```python
from keras.metrics import AUC
m = AUC()
m.update_state(y_test, model.predict(X_test))
print(m.result().numpy())
```

    7587/7587 [==============================] - 10s 1ms/step
    0.9895165


AUC of 0.989 is good, pat yourself on the back for successfully navigating this wonky dataset and training a successful deep neural network.

## Another Approach - Random Forest (Using Pandas)

#### Data Preprocessing


```python
import pandas as pd
act_train = pd.read_csv('act_train.csv')
act_test = pd.read_csv('act_test.csv')
people = pd.read_csv('people.csv')
```


```python
# Convert features in people and activities into integers

def preprocess_act(data, train_set=True):
    data = data.drop(['date', 'activity_id'], axis=1)
    if(train_set):
        data = data.drop(['outcome'], axis=1)
    
    data['people_id'] = data['people_id'].apply(lambda x: x.split('_')[1])
    data['people_id'] = pd.to_numeric(data['people_id']).astype(int)
    
    columns = list(data.columns)
    
    # Convert strings into integers
    for col in columns[1:]:
        data[col] = data[col].fillna('type 0')
        data[col] = data[col].apply(lambda x: x.split(' ')[1])
        data[col] = pd.to_numeric(data[col]).astype(int)
    return data


def preprocess_people(data):
    data = data.drop(['date'], axis=1)
    data['people_id'] = data['people_id'].apply(lambda x: x.split('_')[1])
    data['people_id'] = pd.to_numeric(data['people_id']).astype(int)
    
    # Values are booleans and strings    
    columns = list(data.columns)
    bools = columns[11:]
    strings = columns[1:11]
    
    for col in bools:
        data[col] = pd.to_numeric(data[col]).astype(int)        
    for col in strings:
        data[col] = data[col].fillna('type 0')
        data[col] = data[col].apply(lambda x: x.split(' ')[1])
        data[col] = pd.to_numeric(data[col]).astype(int)
    return data
```


```python
# Preprocess each df
people2 = preprocess_people(people)
action_train = preprocess_act(act_train)
action_test = preprocess_act(act_test, train_set=False)
```

#### Merging People and Activities


```python
# Merge into a unified table

# Training 
features = action_train.merge(people2, how='left', on='people_id')
labels = act_train['outcome']

# Testing
test = action_test.merge(people2, how='left', on='people_id')

features.sample(10)
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>people_id</th>
      <th>activity_category</th>
      <th>char_1_x</th>
      <th>char_2_x</th>
      <th>char_3_x</th>
      <th>char_4_x</th>
      <th>char_5_x</th>
      <th>char_6_x</th>
      <th>char_7_x</th>
      <th>char_8_x</th>
      <th>...</th>
      <th>char_29</th>
      <th>char_30</th>
      <th>char_31</th>
      <th>char_32</th>
      <th>char_33</th>
      <th>char_34</th>
      <th>char_35</th>
      <th>char_36</th>
      <th>char_37</th>
      <th>char_38</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>327413</th>
      <td>150560</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>64</td>
    </tr>
    <tr>
      <th>1829725</th>
      <td>397500</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>43</td>
    </tr>
    <tr>
      <th>146513</th>
      <td>117883</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>58</td>
    </tr>
    <tr>
      <th>1836647</th>
      <td>40482</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>62</td>
    </tr>
    <tr>
      <th>671469</th>
      <td>2129</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>89</td>
    </tr>
    <tr>
      <th>1419608</th>
      <td>335146</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>98</td>
    </tr>
    <tr>
      <th>983613</th>
      <td>266504</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>89</td>
    </tr>
    <tr>
      <th>464413</th>
      <td>175936</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1264726</th>
      <td>306770</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>50</td>
    </tr>
    <tr>
      <th>1399409</th>
      <td>331627</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>82</td>
    </tr>
  </tbody>
</table>
<p>10 rows  51 columns</p>

#### Splitting the Data into a Training Set and a Testing Set


```python
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=23)
```

#### Training a Random Forest Classifier


```python
# Random Forest
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_auc_score
clf = RandomForestClassifier()
clf.fit(X_train, y_train)
```




    RandomForestClassifier()



#### AUC


```python
probability = clf.predict_proba(X_test)
prediction = probability[:,1]
score = roc_auc_score(y_test, prediction)
print("Area under ROC (AUC): {0}".format(score))
```

    Area under ROC (AUC): 0.9972296701621046



```python
# Plot
import matplotlib.pyplot as plt
from sklearn import metrics

fpr, tpr, _ = metrics.roc_curve(y_test,  prediction)
auc = metrics.roc_auc_score(y_test, prediction)
plt.plot(fpr,tpr,label="AUC="+str(auc))
plt.title('ROC Curve')
plt.legend(loc='lower right')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()
```


    
<!-- ![png](AML_files/AML_129_0.png) -->
    
<!-- ![image](https://user-images.githubusercontent.com/85979611/205758328-372d2b94-2799-40fe-a9e2-7888adb2002b.png) -->

![image](https://user-images.githubusercontent.com/85979611/205758474-993831d3-39fa-46b3-a722-a11c4b19c7b1.png)



<br>

<br>

<br>

<br>

<br>


## Results & Conclusion

We got a Catboost model with 87% accuracy on training data, and 87.2% accuracy on unseen (test) data. A (relatively) simple Keras Neural Network achieved 98.5% accuracy on training data, and 97.3% accuracy on unseen (test) data.
Additionally, the Random Forest model got an AUC score of 0.997.


## Lessons Learned - Data Leak

These results seemed shockingly good, so we dug a little bit deeper. We discovered that a large portion of the dataset consisted of completely duplicated data.


> **Artificially inflated test scores**


Removing these duplicates led to a slight decrease in the overall performance of both the tree-based models, and the neural network.


## Future Work


*   **Stochastic Gradient Descent** - If this data is generated from user actions on a website, we want to be able to shape our model continuously over time without retraining on the entire dataset each time.

*   **Time-Series** - Many users in this dataset perform a variety of different actions over time. Considering previous actions of a person (if any) may result in a model with greater predictive power.


*   **Streaming** - Considering RedHat as a relatively large company, it seems likely that this data is being generated at a high velocity, continuously. A true solution to this problem should be able to train and predict using streaming data, which makes Spark / Kafka strong candidates.

